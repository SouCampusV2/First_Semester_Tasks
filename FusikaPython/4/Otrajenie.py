import math
# tol - это допустимая погрешность
def golden_section_search(func, a, b, tol=1e-5):
    # Рассчитываем значение золотого сечения и сохраняем его в переменной phi и его обратное значение
    phi = (1 + math.sqrt(5)) / 2
    resphi = 2 - phi

    x1 = b - resphi * (b - a) # Рассчитываем новую точку x1 внутри интервала [a, b] с использованием золотого сечения.
    x2 = a + resphi * (b - a) # Рассчитываем новую точку x2 внутри интервала [a, b] с использованием золотого сечения.

    # Вычисляем значение функции в точках
    f1 = func(x1)
    f2 = func(x2)

    # Цикл который выполняет метод золотого сечения и он применяется для нахождения минимума функции на отрезке. 
    # Он разбивает текущий отрезок на две части и выбирает ту часть, 
    # в которой функция принимает меньшее значение.
    while math.fabs(b - a) > tol:
        if f1 < f2:
            # Если значение функции в точке x1 меньше, чем в точке x2, то:
            b = x2 # Переносим правую границу интервала в точку x2.
            x2 = x1 # Обновляем точку x2. 
            f2 = f1 # Обновляем значение функции 
            x1 = b - resphi * (b - a) # Рассчитываем новую точку x1.
            f1 = func(x1) # Обновляем значение функции в точке x1.
        else:
            # Все тоже самое только в лево
            a = x1
            x1 = x2
            f1 = f2
            x2 = a + resphi * (b - a)
            f2 = func(x2)

    return (a + b) / 2

def calculate_time(x, a, b, v1, v2):
    # Просто находим время за формулой (не уверен что правильно, просто гуглю не изучая идеально матерял физики)
    time_to_C = math.sqrt(a**2 + x**2) / v1  # Время от A до C
    time_to_B = math.sqrt(b**2 + (a - x)**2) / v2  # Время от C до B
    return time_to_C + time_to_B

# Исходные данные
a = 3  # расстояние от A до границы раздела
b = 4  # расстояние от B до границы раздела
v1 = 1  # скорость света в первой среде
v2 = 1.5  # скорость света во второй среде

# Расчет мин. времени. Функция golden section search + которая принимает в качестве аргументов:
# - Анонимную функцию, которую мы хотим минимизировать.
# - Начальную точку интервала поиска (0).
# - Конечную точку интервала поиска (a + b), так как интересующий нас интервал для x находится между 0 и a + b.
# - x_optimal: Результат выполнения метода золотого сечения, представляющий оптимальное значение x, при котором достигается минимум функции.
x_optimal = golden_section_search(lambda x: calculate_time(x, a, b, v1, v2), 0, a + b)

min_time = calculate_time(x_optimal, a, b, v1, v2)

# Вывод результатов
print(f"Оптимальное положение точки C (x): {x_optimal}")
print(f"Минимальное время прохождения света: {min_time} сек")
